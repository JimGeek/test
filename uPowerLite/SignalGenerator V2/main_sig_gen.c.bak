#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "main_sig_gen.h"
#include "lcd.h"
#include "font.h"
#include "functions.h"
#include "bitmap.h"
#include "define.h"

extern long Frequency,Amplitude;
extern unsigned char FastSweepMode;

unsigned char SineText[] = "SINE";
unsigned char TriText[] = "TRI";
unsigned char SquText[] = "SQU";
int frqUnitindex = 0;

void update_frq_unit()
{
	unsigned char Hz[] = "Hz";
	unsigned char kHz[] = "kHz";
	LCD_paint_block(FREQ_UNIT_START_X,FREQ_UNIT_START_Y,FREQ_UNIT_START_X + 40,FREQ_UNIT_START_Y + 30,0);
	if(frqUnitindex)
	{
		LCD_OutText(FREQ_UNIT_START_X+10,FREQ_UNIT_START_Y,(void *)kHz,YELLOW);
	}
	else
	{
		LCD_OutText(FREQ_UNIT_START_X+10,FREQ_UNIT_START_Y,(void *)Hz,YELLOW);
	}
}

void update_frq_SWAP()
{
	unsigned char SwapMode[] = "F";
	unsigned char SwapMode1[] = "S";
	LCD_paint_block(FREQ_UNIT_START_X+45,FREQ_UNIT_START_Y,FREQ_UNIT_START_X + 65,FREQ_UNIT_START_Y + 30,0);

	if(10 == FastSweepMode)
	{
		LCD_OutText(FREQ_UNIT_START_X+45,FREQ_UNIT_START_Y,(void *)SwapMode,YELLOW);
	}
	else
	{
		LCD_OutText(FREQ_UNIT_START_X+45,FREQ_UNIT_START_Y,(void *)SwapMode1,YELLOW);
	}
}


void update_frequency_value()
{
	unsigned char buffer[10];
	long tmpval,tmpfrq,frq;
	
	frq = (Frequency / 10);
	
	LCD_paint_block(FREQ_VALUE_START_X-8,FREQ_VALUE_START_Y,FREQ_VALUE_START_X + 25,FREQ_VALUE_START_Y + 30,0);
	if(frq >= 0 && frq < 100)
	{		
		if(frqUnitindex)
		{
			frqUnitindex = 0;
			update_frq_unit();
		}
		tmpval = Frequency/10;
		tmpfrq = Frequency;
		if(frq<10)
			sprintf( buffer,"0%ld.%ld",tmpval,(tmpfrq % 10));
		else
			sprintf( buffer,"%ld.%ld",tmpval,(tmpfrq % 10));
		LCD_OutText(FREQ_VALUE_START_X-8,FREQ_VALUE_START_Y,buffer,BLUE);
	}
	else if(frq >= 100 && frq < 1000)
	{
		//LCD_paint_block(FREQ_VALUE_START_X-4,FREQ_VALUE_START_Y,FREQ_VALUE_START_X + 30,FREQ_VALUE_START_Y + 30,0);
		if(frqUnitindex)
		{
			frqUnitindex = 0;
			update_frq_unit();
		}

		tmpval = Frequency/10;
		sprintf( buffer,"%ld",tmpval);
		LCD_OutText(FREQ_VALUE_START_X-4,FREQ_VALUE_START_Y,buffer,BLUE);
	}
	else if(frq >= 1000 && frq < 10000)
	{
		//LCD_paint_block(FREQ_VALUE_START_X-4,FREQ_VALUE_START_Y,FREQ_VALUE_START_X + 30,FREQ_VALUE_START_Y + 30,0);
		if(!frqUnitindex)
		{
			frqUnitindex = 1;
			update_frq_unit();
		}
		tmpval = Frequency/10;
		tmpfrq = (tmpval % 1000);
		tmpfrq = tmpfrq / 10;
		tmpval = tmpval / 1000;
		sprintf(buffer,"%ld.%ld",tmpval,tmpfrq);
		LCD_OutText(FREQ_VALUE_START_X-8,FREQ_VALUE_START_Y,buffer,BLUE);
	}
	else if(Frequency >= 10000.0 && Frequency <= 100000.0)
	{
		//LCD_paint_block(FREQ_VALUE_START_X-4,FREQ_VALUE_START_Y,FREQ_VALUE_START_X + 30,FREQ_VALUE_START_Y + 30,0);
		tmpval = Frequency;
		tmpfrq = (tmpval % 1000);
		tmpfrq = tmpfrq / 100;	
		tmpval = tmpval / 1000;
		sprintf(buffer,"%ld.%ld",tmpval,tmpfrq);
		LCD_OutText(FREQ_VALUE_START_X-8,FREQ_VALUE_START_Y,buffer,BLUE);
	}	
	
}

void update_amplitude_value()
{
	unsigned char buffer[10];
	int tmpval = Amplitude,tmpamp = Amplitude * 10;
	LCD_paint_block(FREQ_VALUE_START_X,AMP_START_Y,FREQ_VALUE_START_X + 25,AMP_START_Y + 30,0);
	sprintf( buffer,"%d.%d",tmpval,(tmpamp%10));
	LCD_OutText(FREQ_VALUE_START_X,AMP_START_Y,buffer,GRAY);
}

void Display_Wave_Type(unsigned char waveType)
{
	LCD_paint_block(FREQ_WAVE_START_X,FREQ_WAVE_START_Y,FREQ_WAVE_START_X + 50,FREQ_WAVE_START_Y + 30,0);
	LCD_paint_block(FREQ_WAVE_START_X,AMP_START_Y,FREQ_WAVE_START_X + 50,AMP_START_Y + 33,0);
	//paint block for symbol
	switch(waveType)
	{
		case WAVE_TYPE_SINE:
		{
			LCD_OutText(FREQ_WAVE_START_X,FREQ_WAVE_START_Y,SineText,WHITE);
			LCD_bitmap (FREQ_WAVE_START_X,AMP_START_Y,(unsigned char rom *)sine,WHITE);
			
			Amplitude = 1.0;
			update_amplitude_value();
			DDS_SINE_WAVE = 1;
			delay_ms(1000);
			DDS_SINE_WAVE = 0;
		}
		break;
		case WAVE_TYPE_TRI:
		{
		 	LCD_OutText(FREQ_WAVE_START_X,FREQ_WAVE_START_Y,TriText,GRAY);
			LCD_bitmap (FREQ_WAVE_START_X - 5,AMP_START_Y,(unsigned char rom *)triangle,GRAY);
		}
		break;
		case WAVE_TYPE_SQUARE:
		{
			LCD_OutText(FREQ_WAVE_START_X,FREQ_WAVE_START_Y,SquText,WHITE);
			LCD_bitmap (FREQ_WAVE_START_X,AMP_START_Y,(unsigned char rom *)square,WHITE);
			Amplitude = 3.3;
			update_amplitude_value();
			DDS_SQUARE_WAVE = 1;
			delay_ms(1000);
			DDS_SQUARE_WAVE = 0;
		}
		break;
	}
}
void display_home_page(void)
{
	int x_start,y_start;
	char buffer[6];
	unsigned char HomeText[] = "HOME";
	unsigned char PressMenu[] = "PRESS SAVE TO";
	unsigned char ToChange[] = "STORE CONFIG.";
	//unsigned char temp;

	unsigned char V[] = "V";
	setfont((void *)font_Calibri_10);
	x_start = 0;
	y_start = 0;

	/* Fill LCD background */
	FillFullLcd(0);

	/* Draw Title bar*/
	LCD_paint_block(x_start,y_start,x_start + SIGGEN_LONG_BUTTON_WIDTH,y_start + SIGGEN_LONG_BUTTON_HEIGHT,BLUE);
	LCD_bitmap (x_start,y_start,(unsigned char rom *)home,YELLOW);
	LCD_OutText(x_start + 60,y_start,HomeText,YELLOW);

	update_frequency_value();
	update_frq_unit();
	update_frq_SWAP();

	//temp = Read_b_eep (SIGNAL_TYPE_ADDRESS);
	//Display_Wave_Type(temp);
	update_amplitude_value();

	LCD_OutText(FREQ_UNIT_START_X +10,AMP_START_Y,(void *)V,GREEN);

	/* Draw Amplitude bar*/
	LCD_paint_block(x_start,128 - SIGGEN_LONG_BUTTON_HEIGHT,x_start + SIGGEN_LONG_BUTTON_WIDTH,128,BLUE);
	LCD_OutText(x_start + 30,90,(void *)PressMenu,YELLOW);
	LCD_OutText(x_start + 30,104,(void *)ToChange,YELLOW);
}


void dds_init(void)
{
	// Set the desired output values for the DDS pins
								// want reset pin high to reset the DDS
	DDS_DATA  = LOW;
	DDS_WCLK  = LOW;
	DDS_FQ    = LOW;

	DDS_RESET = HIGH;
	// OK, DDS is currently in reset & the Xmega DDS ports are configured as outputs.
	// Wait a moment to give the DDS a nice long reset pulse
	delay(10000);
	delay(10000);

	// Take DDS out of reset, put DDS into serial data communication mode
	DDS_RESET = LOW;

	delay(10000);
	// Enable serial mode. See Fig 17 in the AD9851 datasheet. We have pins D2-0
	// wired appropriately on the PCB, so we just need to toggle WCLK & FQ.

	DDS_WCLK = HIGH;
	//delay(100);
	DDS_WCLK = LOW;
	//delay(100);

	DDS_FQ = HIGH;
	//delay(100);
	DDS_FQ = LOW;
	//delay(100);
}

